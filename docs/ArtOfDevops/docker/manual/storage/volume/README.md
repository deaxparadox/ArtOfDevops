# Docker volumnes

### Table of content

[Introduction](#introduction)
[Using a volume with docker compose ðŸ”—](start-service-with-volumes.md)


### Introduction

Volumes are persistent storage mechanisms managed by the Docker daemon. They retain data even after the containers using them are removed. Volume data is stored on the filesystem on the host, but in order to interact with the data in the volume, you must mount the volume to a container. Directly accessing or interacting with the volume data is unsupported, undefined behavior, and may result in the volume or its data breaking in unexpected ways.

Volumes are ideal for performance-critical data processing and long-term storage needs. Since the storage location is managed on the daemon host, volumes provide the same raw file performance as accessing the host filesystem directly.


### Creating docker volume

To create a volume explicitly using command, run the following command:

```sh
$ docker volume create
```

or Docker can create a volume during container or server creation.

### When to use volumes

Volumes are the preferred mechanism for persisting data generated by and used by Docker containers, volumes are completely manager by Docker.

Volumes are good choice for the following use cases:

- Volumes are easier to back up or migrate than bind mounts.
- You can manage volumes using Docker CLI commands or the Docker API.
- Volumes work on both Linux and Windows containers.
- Volumes can be more safely shared among multiple containers.
- New volumes can have their content pre-populated by a container or build.
- When your application requires high-performance I/O.

Volumes are not a good choice if you need to access the files from the host, as the volume are completely manager by Docker. 

----------

- Use **bind mount** if you need to access files or directories from both containers and the host.

- If you container generates non-persistent state data, consider using a **tmpfs mount** to avoid storing the data anywhere permanently.

----------

Volumes use `rprivate` (recursive private) bind propagation, and bind propagation isn't configurable for volumes.

Using a volume ensures that the data is persisted even if the container using it is removed.

A given volume can be mounted into multiple containers simultaneously. When no running container is using a volume, the volume is still available to Docker and isn't removed automatically. 

You can remove unused volumes using:

```sh
$ docker volume prune
```

### Mounting a volume over existing data

If you mount a *non-empty volume* into a directory in the container in which files or directories exist, the pre-existing files are obscured by the mount. This is similar to if you were to save files into `/mnt` on a Linux host, and then mounted a USB drive into `/mnt`. The contents of `/mnt` would be obscured by the contents of the USB drive until the USB drive was unmounted.

With containers, there's no straightforward way of removing a mount to reveal the obscured files again. Your best option is to recreate the container without the mount.

If you mount an *empty volume* into a directory in the container in which files or directories exist, these files or directories are propagated (copied) into the volume by default. Similarly, if you start a container and specify a volume which does not already exist, an empty volume is created for you. This is a good way to pre-populate data that another container needs.

To prevent Docker from copying a container's pre-exisiting files into an empty volumn, use the `volume-nocopy` option.

### Named and anonymous volumes

A volume may be named or anonymous. Anonymous volumes are given a random name that's guranteed to be unique within a given Docker host.

To remove docker volume as the docker container get destroyed, using `--rm` flag.

### Syntax

To mount a volume with the `docker run` command, you can use either the `--mount` or `--volume` flag.


#### `--mount` flag

```bash
 docker run --mount type=volume,src=<volume-name>,dst=<mount-path>
```

This flag is more explicit and supports all the available options.

The `--mount` flag consists of multiple key-value pairs, separated by commas and each consisting of a `<key>=<value>` tuple.

```bash
$ docker run --mount type=volume[,src=<volume-name>],dst=<mount-path>[,<key>=<value>...]
```

Options for `--mount type=volume`:

| Option | Description |
|-----|-----|
| `source`, `src` | The source of the mount. For named volumes, this is the name of the voume. For anonymous volumes, this field is omitted. |
| `destination`, `dst`, `target` | The path where the file or directory is mounted in the container. |
| `volume-subpath` | A path to a subdirectory within the volume to mount into the container. The subdirectory must exist in the volume before the volume is mounted to a container. |
| `readonly`, `ro` | If present, causes the volume to be mounted into the container as read-only. |
| `volume-nocopy` | If present, data at the destination isn't copied into the volume if the volume is empty. By default, content at the target destination get copied into a mounted volume if empty. |
| `volume-opt` | Can be specified more than once, takes a key-value pair consisting of the option name and its value. |


Example

```bash
$ docker run --mount type=volume,src=myvolume,dst=/data,ro,volume-subpath=/foo
```

#### `--volume` flag

```bash
$ docker run --volume <volume-name>:<mount-path>
```

Options for --volume:

The `--volume` or `-v` flag consists of three fields, separated by colon characters (`:`). The fields must be in the correct order.

```bash
$ docker run -v [<volume-name>:]<mount-path>[:opts]
```

In the case of named volumes, the first fields i the name of the volume, and is unique on the given host machine.

For anonymous volumes, the first fields is omitted. The seond fields is the path where the file or directry is mounted in the container.

The third fields is optional, and is a comma-separated list of options. valid options for `--volume` with a data volume include:

| Option | Description |
| `readonly`, `ro` | If present, causes the volume to be mounted into the container as read-only. |
| `volume-nocopy` | If present, data at the destination isn't copied into the volume if the volume is empty. By default, content at the target destination get copied into a mounted volume if empty. |

Example

```bash
$ docker run -v myvolume:/data:ro
```


### Create and manage volumes

You can create and manage the volumes outside the scope of any container.

Create a volume:

```bash
docker volume create my-vol
```

List volumes:


```bash
docker volume ls

local               my-vol
```

Inspect a volume:

```bash
docker volume inspect my-vol
[
    {
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
        "Name": "my-vol",
        "Options": {},
        "Scope": "local"
    }
]
```

Remove a volume:

```bash
$ docker volume rm my-vol
```


### Start a container with a volume

If you start a container with a volume that doesn't yet exist, Docker creates the volume for you. 

The following example mounts the volume `myvol2` into `/app/` in the container.

Using `--mount` flag:

```bash
$ docker run -d --name devtest --mount source=myvol2,target=/app nginx:latest
```

To verify, run the following command:

```bash
$ docker inspect devtest
[
    {
        "Id": "068bda2bd1f949275b96743ba05405b2ed5e2ad6d6db7b43664e8c99dfdda052",
        "Created": "2025-02-12T18:16:57.212551766Z",
        "Path": "/docker-entrypoint.sh",
        "Args": [
            "nginx",
            "-g",
            "daemon off;"
        ],

Output omitted...
```

This shows that the mount is a volume, it shows the correct source and destination, and that the mount is read-write.

To stop the contanier:

```bash
$ docker container stop devtest
```

To remove the container:

```bash
$ docker container rm devtest
```

To remove the volume:

```bash
$ docker volume rm myvol2
```

or 

```bash
$ docker volume rm myvol2
```

